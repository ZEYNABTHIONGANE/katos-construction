rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isChef() {
      return isAuthenticated() &&
             firestore.exists(/databases/(default)/documents/users/$(request.auth.uid)) &&
             firestore.get(/databases/(default)/documents/users/$(request.auth.uid)).data.role == 'chef';
    }

    function isClient() {
      return isAuthenticated() &&
             firestore.exists(/databases/(default)/documents/users/$(request.auth.uid)) &&
             firestore.get(/databases/(default)/documents/users/$(request.auth.uid)).data.role == 'client';
    }

    function getClientProjectId() {
      return firestore.get(/databases/(default)/documents/users/$(request.auth.uid)).data.projectId;
    }

    function isProjectParticipant(projectId) {
      return isChef() || (isClient() && getClientProjectId() == projectId);
    }

    function isValidImageType() {
      return request.resource.contentType.matches('image/.*');
    }

    function isValidVideoType() {
      return request.resource.contentType.matches('video/.*');
    }

    function isValidMediaType() {
      return isValidImageType() || isValidVideoType();
    }

    function isValidFileSize() {
      // Max 50MB for videos, 10MB for images
      return (isValidVideoType() && request.resource.size <= 50 * 1024 * 1024) ||
             (isValidImageType() && request.resource.size <= 10 * 1024 * 1024);
    }

    // Project media files: /projects/{projectId}/media/{mediaId}/{filename}
    match /projects/{projectId}/media/{mediaId}/{filename} {
      // Read: accessible by project participants
      allow read: if isProjectParticipant(projectId);

      // Write: chefs can always upload, clients can upload to their project
      allow write: if isValidMediaType() &&
                     isValidFileSize() &&
                     (isChef() || (isClient() && getClientProjectId() == projectId));

      // Delete: only chefs can delete media files
      allow delete: if isChef();
    }

    // Project documents: /projects/{projectId}/documents/{filename}
    match /projects/{projectId}/documents/{filename} {
      // Read: accessible by project participants
      allow read: if isProjectParticipant(projectId);

      // Write: chefs can upload documents, clients with restrictions
      allow write: if request.resource.size <= 20 * 1024 * 1024 && // Max 20MB
                     (isChef() || (isClient() && getClientProjectId() == projectId));

      // Delete: only chefs can delete documents
      allow delete: if isChef();
    }

    // User profile pictures: /users/{userId}/profile/{filename}
    match /users/{userId}/profile/{filename} {
      // Read: accessible by all authenticated users
      allow read: if isAuthenticated();

      // Write: user can only upload their own profile picture
      allow write: if isAuthenticated() &&
                     request.auth.uid == userId &&
                     isValidImageType() &&
                     request.resource.size <= 5 * 1024 * 1024; // Max 5MB

      // Delete: user can delete their own profile picture
      allow delete: if isAuthenticated() && request.auth.uid == userId;
    }

    // Catalog images: /catalog/{category}/{itemId}/{filename}
    match /catalog/{category}/{itemId}/{filename} {
      // Read: accessible by all authenticated users
      allow read: if isAuthenticated();

      // Write/Delete: only chefs can manage catalog images
      allow write, delete: if isChef() &&
                             isValidImageType() &&
                             request.resource.size <= 10 * 1024 * 1024; // Max 10MB
    }

    // Block all other paths
    match /{allPaths=**} {
      allow read, write: if false;
    }

    // TODO: Future enhancements for production
    // - Add virus scanning integration
    // - Implement image resizing and optimization
    // - Add watermarking for sensitive content
    // - Rate limiting for uploads
    // - Audit logging for file operations
    // - Support for temporary signed URLs
    // - Backup and versioning strategies
  }
}